package process;

import java.util.ArrayList;

import main.Slicer;
import math.geom2d.Point2D;
import math.geom3d.Point3D;
import math.geom3d.Vector3D;
import structs.Extrusion2D;
import structs.Extrusion3D;
import structs.Extrusion2D.ET;
import utils.Utils2D;
import utils.Utils3D;

/**
 *  
 * @author Nick
 * Translate an Extrusion2D path into Extrusion3D by projecting it onto the layer shape mesh.
 * Requires that s.shape.offset==0
 */
public class Reproject {
	private double offset;
	private Slicer s;
	/**
	 * Main reprojection method.
	 * @param path 2D path to project onto the layer shape.
	 * @param offset Height to place the layer shape at.
	 * @param s Slicer to retrieve the layer shape from.
	 * @return A list of Extrusion3D paths generated by projecting path onto s.shape.
	 */
	public Reproject(double offset, Slicer s){
		this.offset = offset;
		this.s = s;
	}
	/**
	 * Change the offset height of the surface you're projecting onto.
	 * @param o New offset height.
	 */
	public void setOffset(double o){
		this.offset = o;
	}
	/**
	 * Project a series of 2d extrusions which have already been segmented based on
	 * the topology of the surface stored in slicer s.
	 * @param path Path to project.
	 * @return A continuous path of 3d extrusions.
	 */
	public ArrayList<Extrusion3D> Proj(ArrayList<Extrusion2D> path){
		ArrayList<Extrusion3D> output = new ArrayList<Extrusion3D>();
		ArrayList<Extrusion2D> travels = new ArrayList<Extrusion2D>();
		for(Extrusion2D e: path){
			if(e.ExtrusionType==ET.travel||e.ExtrusionType==ET.nonretracting){
				travels.add(e);
				continue;
			}
			if(!travels.isEmpty()){
				//End of a series of travels, since we didn't just hit continue.
				output.addAll(projectTravel(travels,e.firstPoint()));
				travels.clear();
				//Don't continue here, because e isn't part of the travels we just handled.
			}
			output.add(projectExtrusion(e));
		}
		return output;
	}
	/**
	 * Project ansegment onto s.shape.
	 * @param e 2D extrusion to project.
	 * @param s Slicer to retrieve shape from.
	 * @return An Extrusion3D path with the same type as e.
	 */
	private Extrusion3D projectExtrusion(Extrusion2D e){
		return new Extrusion3D(projectPoint(e.firstPoint()), projectPoint(e.lastPoint()), e.ExtrusionType);
	}
	/**
	 * Project point p onto the layer shape, or the plane at z=s.zMin if the
	 * normal projection falls below it.
	 * @param p Point to project
	 * @return A new Point3D object.
	 */
	private Point3D projectPoint(Point2D p){
		Point3D hit = s.shape.project(p);

        if(hit == null) {
            // If we failed to project the point, just project the 2d point in to 3d space by directly converting a 2d point in to a 3d point, using a calculated z height.
            hit = new Point3D(p.getX(), p.getY(), to());
        }

		if(hit.getZ()+to()<s.zMin){	//TODO reimplement this check in a way that doesn't cause discontinuities.
			return new Point3D(hit.getX(),hit.getY(),s.zMin);
		}
		return new Point3D(hit.getX(),hit.getY(),hit.getZ()+to());
	}
	/**
	 * Place an Extrusion2D at a given z to create a flat Extrusion3D.
	 * @param e 2d extrusion segment
	 * @param z height to place segment at.
	 * @return 3d extrusion segment parallel to the XY plane.
	 */
	private static Extrusion3D setZ(Extrusion2D e, double z){
		return new Extrusion3D(Utils2D.setZ(e.firstPoint(), z),Utils2D.setZ(e.lastPoint(), z),e.ExtrusionType);
	}
	/**
	 * Transforms a series of 2D travel moves length>=1 into a series of 3D travel moves which
	 * go up to their maximum height then lower straight down to the end point, without
	 * dropping into any valleys in between.
	 * @param travels
	 * @param s
	 * @return
	 */
	private ArrayList<Extrusion3D> projectTravel(ArrayList<Extrusion2D> travels, Point2D end){
		boolean SlopeDown = projectPoint(travels.get(0).firstPoint()).getZ()>projectPoint(end).getZ(); //Checks whether this path needs to be sloped down at the end.
		double ModelTop = s.part.boundingBox().getMaxZ()+s.lift+s.layerHeight; //Extra margin of 1 layer height.
		ArrayList<Extrusion3D> output = new ArrayList<Extrusion3D>();
		Extrusion3D first = projectExtrusion(travels.get(0));
		Point3D last = first.firstPoint();
		double z = last.getZ();
		if(s.lift!=0){
			//If lift is nonzero, add a movement from the actual start of the travel series to +lift above it.
			//Add the movement at the end so indexing matches up between travels and output for the slope down loop.
			z+=s.lift;
		}
		for(Extrusion2D e : travels){
			Extrusion3D proj = projectExtrusion(e);
			double newZ = proj.lastPoint().getZ()+s.lift;
			//Move up, but not past the top of the part.
			if(newZ>z){ //If we need to keep sloping up on this one.
				Point3D next = newZ<=ModelTop ? liftP(proj.lastPoint(),s.lift) : new Point3D(proj.lastPoint().getX(),proj.lastPoint().getY(),ModelTop);
				Extrusion3D add = new Extrusion3D(last,next,e.ExtrusionType);
				if(Utils3D.slope(add)<0) SlopeDown=true;
				output.add(add);
				z = next.getZ();
				last = next;
				continue;
			}
			output.add(setZ(e,z));
			last = output.get(output.size()-1).lastPoint();
		}
		if(SlopeDown){
			//Slope down the end.
			z=-1e10;
			for(int i=output.size()-1;i>=0;i--){
				Extrusion3D curr = output.get(i);
				Extrusion3D proj = projectExtrusion(travels.get(i));
				double newZ = proj.lastPoint().getZ()+s.lift;
				if(newZ<curr.lastPoint().getZ()){ //If we are still below the path
					//Either slope up or go flat.
					double slope = Utils3D.slope(proj);
					if(newZ>z&&slope>0){
						Point3D newEnd = liftP(proj.lastPoint(),s.lift);
						Point3D newStart = liftP(proj.firstPoint(),s.lift);
						Extrusion3D newE = new Extrusion3D(newStart,newEnd,curr.ExtrusionType);
						slope = (newE.firstPoint().getZ()-newE.lastPoint().getZ())/Utils3D.length(newE);
						output.set(i,new Extrusion3D(newStart,newEnd,curr.ExtrusionType));
						z=newStart.getZ();
					}
					else{
						Point3D lp = proj.lastPoint();
						Point3D newEnd = new Point3D(lp.getX(),lp.getY(),Math.max(lp.getZ(),z));
						Point3D fp = proj.firstPoint();
						Point3D newStart = new Point3D(fp.getX(),fp.getY(),Math.max(fp.getZ(),z));
						output.set(i,new Extrusion3D(newStart,newEnd,curr.ExtrusionType));
						z=newStart.getZ();
					}
				}
				else break;
			}
		}
		if(s.lift!=0){
			//If lift is nonzero, add a movement from the actual start of the travel series to +lift above it.
			Extrusion3D lift = new Extrusion3D(first.firstPoint(),liftP(last,s.lift),first.ExtrusionType);
			output.add(0,lift);
			z+=s.lift;
		}
		//		Extrusion3D lastE = output.get(output.size()-1);
		//		Extrusion3D lower = new Extrusion3D(lastE.lastPoint(),liftP(s.shape.project(end),to()),lastE.ExtrusionType);
		//		output.add(lower);
		return output;
	}
	/**
	 * @param p Point to lift
	 * @param d Distance to lift.
	 * @return A copy of p s.lift mm above p's position.
	 */
	private Point3D liftP(Point3D p, double d) {
		return p.plus(new Vector3D(0,0,d));
	}
	/**
	 * Apply the offset of this Reproject instance to the given Extrusion3D.
	 * @param e Extrusion to offset.
	 * @return A new Extrusion3D instance moved in the +Z direction.
	 */
	@SuppressWarnings("unused")
	private Extrusion3D liftE(Extrusion3D e){
		return new Extrusion3D(liftP(e.firstPoint(),to()),liftP(e.lastPoint(),to()),e.ExtrusionType);
	}
	/**
	 * @return The difference between this Reproject instance's offset value and shape's current offset.
	 */
	private double to(){
		return offset - s.shape.getOffset();
	}
}
