package process;

import java.util.ArrayList;

import process.Extrusion2D.ET;
import math.geom2d.Point2D;
import math.geom3d.Point3D;
import math.geom3d.Vector3D;
import utils2D.Utils2D;

/**
 *  
 * @author Nick
 * Translate an Extrusion2D path into Extrusion3D by projecting it onto the layer shape mesh.
 * Requires that s.shape.offset==0
 */
public class Reproject {
	private double offset;
	private Slicer s;
	/**
	 * Main reprojection method.
	 * @param path 2D path to project onto the layer shape.
	 * @param offset Height to place the layer shape at.
	 * @param s Slicer to retrieve the layer shape from.
	 * @return A list of Extrusion3D paths generated by projecting path onto s.shape.
	 */
	public Reproject(double offset, Slicer s){
		this.offset = offset;
		this.s = s;
	}
	/**
	 * Change the offset height of the surface you're projecting onto.
	 * @param o New offset height.
	 */
	public void setOffset(double o){
		this.offset = o;
	}
	/**
	 * Project a series of 2d extrusions which have already been segmented based on
	 * the topology of the surface stored in slicer s.
	 * @param path Path to project.
	 * @return A continuous path of 3d extrusions.
	 */
	public ArrayList<Extrusion3D> Proj(ArrayList<Extrusion2D> path){
		ArrayList<Extrusion3D> output = new ArrayList<Extrusion3D>();
		ArrayList<Extrusion2D> travels = new ArrayList<Extrusion2D>();
		for(Extrusion2D e: path){
			if(e.ExtrusionType==ET.travel||e.ExtrusionType==ET.nonretracting){
				travels.add(e);
				continue;
			}
			if(!travels.isEmpty()){
				//End of a series of travels, since we didn't just hit continue.
				output.addAll(projectTravel(travels,e.firstPoint()));
				travels.clear();				
			}
			output.add(projectExtrusion(e));
		}
		return output;
	}
	/**
	 * Project a shell or infill segment onto s.shape.
	 * @param e 2D extrusion to project.
	 * @param s Slicer to retrieve shape from.
	 * @return An Extrusion3D path with the same type as e.
	 */
	private Extrusion3D projectExtrusion(Extrusion2D e){
		return new Extrusion3D(projectPoint(e.firstPoint()), projectPoint(e.lastPoint()), e.ExtrusionType);
	}
	/**
	 * Project point p onto the layer shape, or the plane at z=s.zMin if the
	 * normal projection falls below it.
	 * @param p Point to project
	 * @return A new Point3D object.
	 */
	private Point3D projectPoint(Point2D p){
		Point3D hit = s.shape.project(p);
//		if(hit.getZ()+to()<s.zMin){	//TODO reimplement this check in a way that doesn't cause discontinuities.
//			return new Point3D(hit.getX(),hit.getY(),s.zMin);
//		}
		return new Point3D(hit.getX(),hit.getY(),hit.getZ()+to());
	}
	/**
	 * Place an Extrusion2D at a given z to create a flat Extrusion3D.
	 * @param e 2d extrusion segment
	 * @param z height to place segment at.
	 * @return 3d extrusion segment parallel to the XY plane.
	 */
	private static Extrusion3D setZ(Extrusion2D e, double z){
		return new Extrusion3D(Utils2D.setZ(e.firstPoint(), z),Utils2D.setZ(e.lastPoint(), z),e.ExtrusionType);
	}
	/**
	 * Transforms a series of 2D travel moves length>=1 into a series of 3D travel moves which
	 * go up to their maximum height then lower straight down to the end point, without
	 * dropping into any valleys in between.
	 * @param travels
	 * @param s
	 * @return
	 */
	private ArrayList<Extrusion3D> projectTravel(ArrayList<Extrusion2D> travels, Point2D end){
		double ModelTop = s.part.boundingBox().getMaxZ()+s.lift;
		ArrayList<Extrusion3D> output = new ArrayList<Extrusion3D>();
		Extrusion3D first = projectExtrusion(travels.get(0));
		Vector3D rise = new Vector3D(0,0,s.lift);
		Extrusion3D lift = new Extrusion3D(first.firstPoint(),first.firstPoint().plus(rise),ET.nonretracting);	//liftE handled by one applied to first.
		output.add(lift);
		double z = lift.lastPoint().getZ();
		for(Extrusion2D e : travels){
			//Nothing happens here if first was the only edge.
			Extrusion3D proj = projectExtrusion(e);
			double newZ = proj.lastPoint().getZ()+s.lift;
			if(newZ>z&&newZ<ModelTop){	//Don't move up past the top of the part, it's needless.
				//Need to keep sloping up on this one.
				Point3D last = output.get(output.size()-1).lastPoint();
				output.add(new Extrusion3D(last,liftP(proj.lastPoint(),s.lift),e.ExtrusionType));
				z = proj.lastPoint().getZ()+s.lift;
			}
			else output.add(setZ(e,z));
		}
		Extrusion3D last = output.get(output.size()-1);
		Extrusion3D lower = new Extrusion3D(last.lastPoint(),liftP(s.shape.project(end),to()),travels.get(travels.size()-1).ExtrusionType);
		output.add(lower);
		return output;
	}
	/**
	 * @param p Point to lift
	 * @param d Distance to lift.
	 * @return A copy of p s.lift mm above p's position.
	 */
	private Point3D liftP(Point3D p, double d) {
		return p.plus(new Vector3D(0,0,d));
	}
	/**
	 * Apply the offset of this Reproject instance to the given Extrusion3D.
	 * @param e Extrusion to offset.
	 * @return A new Extrusion3D instance moved in the +Z direction.
	 */
	private Extrusion3D liftE(Extrusion3D e){
		return new Extrusion3D(liftP(e.firstPoint(),to()),liftP(e.lastPoint(),to()),e.ExtrusionType);
	}
	/**
	 * @return The difference between this Reproject instance's offset value and shape's current offset.
	 */
	private double to(){
		return offset - s.shape.getOffset();
	}
}
