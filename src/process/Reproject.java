package process;

import java.util.ArrayList;

import main.Slicer;
import math.geom2d.Point2D;
import math.geom3d.Point3D;
import math.geom3d.Vector3D;
import structs.Extrusion2D;
import structs.Extrusion3D;
import structs.Extrusion2D.ET;
import utils2D.Utils2D;

/**
 *  
 * @author Nick
 * Translate an Extrusion2D path into Extrusion3D by projecting it onto the layer shape mesh.
 * Requires that s.shape.offset==0
 */
public class Reproject {
	private double offset;
	private Slicer s;
	/**
	 * Main reprojection method.
	 * @param path 2D path to project onto the layer shape.
	 * @param offset Height to place the layer shape at.
	 * @param s Slicer to retrieve the layer shape from.
	 * @return A list of Extrusion3D paths generated by projecting path onto s.shape.
	 */
	public Reproject(double offset, Slicer s){
		this.offset = offset;
		this.s = s;
	}
	/**
	 * Change the offset height of the surface you're projecting onto.
	 * @param o New offset height.
	 */
	public void setOffset(double o){
		this.offset = o;
	}
	/**
	 * Project a series of 2d extrusions which have already been segmented based on
	 * the topology of the surface stored in slicer s.
	 * @param path Path to project.
	 * @return A continuous path of 3d extrusions.
	 */
	public ArrayList<Extrusion3D> Proj(ArrayList<Extrusion2D> path){
		ArrayList<Extrusion3D> output = new ArrayList<Extrusion3D>();
		ArrayList<Extrusion2D> travels = new ArrayList<Extrusion2D>();
		for(Extrusion2D e: path){
			if(e.ExtrusionType==ET.travel||e.ExtrusionType==ET.nonretracting){
				travels.add(e);
				continue;
			}
			if(!travels.isEmpty()){
				//End of a series of travels, since we didn't just hit continue.
				output.addAll(projectTravel(travels,e.firstPoint()));
				travels.clear();
				//Don't continue here, because e isn't part of the travels we just handled.
			}
			output.add(projectExtrusion(e));
		}
		return output;
	}
	/**
	 * Project ansegment onto s.shape.
	 * @param e 2D extrusion to project.
	 * @param s Slicer to retrieve shape from.
	 * @return An Extrusion3D path with the same type as e.
	 */
	private Extrusion3D projectExtrusion(Extrusion2D e){
		return new Extrusion3D(projectPoint(e.firstPoint()), projectPoint(e.lastPoint()), e.ExtrusionType);
	}
	/**
	 * Project point p onto the layer shape, or the plane at z=s.zMin if the
	 * normal projection falls below it.
	 * @param p Point to project
	 * @return A new Point3D object.
	 */
	private Point3D projectPoint(Point2D p){
		Point3D hit = s.shape.project(p);
		if(hit.getZ()+to()<s.zMin){	//TODO reimplement this check in a way that doesn't cause discontinuities.
			return new Point3D(hit.getX(),hit.getY(),s.zMin);
		}
		return new Point3D(hit.getX(),hit.getY(),hit.getZ()+to());
	}
	/**
	 * Place an Extrusion2D at a given z to create a flat Extrusion3D.
	 * @param e 2d extrusion segment
	 * @param z height to place segment at.
	 * @return 3d extrusion segment parallel to the XY plane.
	 */
	private static Extrusion3D setZ(Extrusion2D e, double z){
		return new Extrusion3D(Utils2D.setZ(e.firstPoint(), z),Utils2D.setZ(e.lastPoint(), z),e.ExtrusionType);
	}
	/**
	 * Transforms a series of 2D travel moves length>=1 into a series of 3D travel moves which
	 * go up to their maximum height then lower straight down to the end point, without
	 * dropping into any valleys in between.
	 * @param travels
	 * @param s
	 * @return
	 */
	private ArrayList<Extrusion3D> projectTravel(ArrayList<Extrusion2D> travels, Point2D end){
		double ModelTop = s.part.boundingBox().getMaxZ()+s.lift+s.layerHeight; //Extra margin of 1 layer height.
		ArrayList<Extrusion3D> output = new ArrayList<Extrusion3D>();
		Extrusion3D first = projectExtrusion(travels.get(0));
		
		Point3D last = first.firstPoint();
		double z = last.getZ();
		if(s.lift!=0){
			//If lift is nonzero, add a movement from the actual start of the travel series to +lift above it.
			Extrusion3D lift = new Extrusion3D(first.firstPoint(),liftP(last,s.lift),first.ExtrusionType);
			output.add(lift);
			z+=s.lift;
		}
		for(Extrusion2D e : travels){
			Extrusion3D proj = projectExtrusion(e);
			double newZ = proj.lastPoint().getZ()+s.lift;
			//Move up, but not past the top of the part.
			if(newZ>z){ //If we need to keep sloping up on this one.
				Point3D next = newZ<=ModelTop ? liftP(proj.lastPoint(),s.lift) : new Point3D(proj.lastPoint().getX(),proj.lastPoint().getY(),ModelTop);
				Extrusion3D add = new Extrusion3D(last,next,e.ExtrusionType);
				output.add(add);
				z = next.getZ();
				last = next;
				continue;
			}
			output.add(setZ(e,z)); //TODO modify this to make travels slope back down instead of dropping vertically.
			last = output.get(output.size()-1).lastPoint();
		}
		Extrusion3D lastE = output.get(output.size()-1);
		Extrusion3D lower = new Extrusion3D(lastE.lastPoint(),liftP(s.shape.project(end),to()),lastE.ExtrusionType);
		output.add(lower);
		return output;
	}
	/**
	 * @param p Point to lift
	 * @param d Distance to lift.
	 * @return A copy of p s.lift mm above p's position.
	 */
	private Point3D liftP(Point3D p, double d) {
		return p.plus(new Vector3D(0,0,d));
	}
	/**
	 * Apply the offset of this Reproject instance to the given Extrusion3D.
	 * @param e Extrusion to offset.
	 * @return A new Extrusion3D instance moved in the +Z direction.
	 */
	private Extrusion3D liftE(Extrusion3D e){
		return new Extrusion3D(liftP(e.firstPoint(),to()),liftP(e.lastPoint(),to()),e.ExtrusionType);
	}
	/**
	 * @return The difference between this Reproject instance's offset value and shape's current offset.
	 */
	private double to(){
		return offset - s.shape.getOffset();
	}
}
